{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf250
{\fonttbl\f0\fnil\fcharset0 Monaco;\f1\fnil\fcharset0 Menlo-Regular;\f2\fmodern\fcharset0 Courier;
}
{\colortbl;\red255\green255\blue255;\red38\green71\blue75;\red100\green56\blue32;\red196\green26\blue22;
\red170\green13\blue145;\red46\green13\blue110;\red0\green116\blue0;\red92\green38\blue153;\red28\green0\blue207;
}
\vieww12040\viewh15240\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs20 \cf0 I would like to do the computations in a child process, so that I can stop PlainCalc from crashing in the case of infinite recursion.\
\

\fs32 Shadowing the calculator state\

\fs20 \
Both the app and the task have a CalcState.  Thus, if the task crashes, I can make a new one and initialize its state to the last function and variable values.\
\
When the calculator task returns 
\f1\fs22 \cf2 \CocoaLigature0 kCalcResult_DefinedFunction
\f0\fs20 \cf0 \CocoaLigature1 , the app passes the line to its own CalcState.\
\
When the calculator task returns 
\f1\fs22 \cf2 \CocoaLigature0 kCalcResult_Calculated
\f0\fs20 \cf0 \CocoaLigature1 , use the symbol name returned from ParseCalcLine, and set that symbol (if any) and 
\f1\fs22 \CocoaLigature0 last
\f0\fs20 \CocoaLigature1  to the computed value, using SetCalcVariable.\
\

\fs32 To prevent a process from triggering the crash reporter\

\f2\fs28 \
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\f1\fs22 \cf3 \CocoaLigature0 #import \cf4 <signal.h>\cf3 \
#import \cf4 <stdlib.h>\cf3 \
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural
\cf5 \
static\cf0  \cf5 void\cf0  sighandler( \cf5 int\cf0  theSig )\
\{\
	\cf6 exit\cf0 ( theSig );\
\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f2\fs28 \cf0 \CocoaLigature1 \
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\f1\fs22 \cf0 \CocoaLigature0 	\cf7 // Set up alternate stack for stack overflow case\cf0 \
	stack_t sigstk;\
	sigstk.\cf8 ss_sp\cf0  = \cf6 malloc\cf0 (\cf3 SIGSTKSZ\cf0 );\
	sigstk.ss_size = \cf3 SIGSTKSZ\cf0 ;\
	sigstk.ss_flags = \cf9 0\cf0 ;\
	\cf6 sigaltstack\cf0 ( &sigstk, \cf5 NULL\cf0  );\
	\
	\cf7 // Set up signal handlers\cf0 \
	\cf5 struct\cf0  sigaction act;\
	act.\cf3 sa_handler\cf0  = sighandler;\
	\cf6 sigemptyset\cf0 ( &act.\cf8 sa_mask\cf0  );\
	act.\cf8 sa_flags\cf0  = \cf3 SA_ONSTACK\cf0 ;\
	\
	\cf5 int\cf0  sa_res = \cf6 sigaction\cf0 ( \cf3 SIGBUS\cf0 , &act, \cf5 NULL\cf0  );\
	\cf7 // and so on for SIGFPE, SIGSEGV, etc\cf0 \
\pard\pardeftab720\ql\qnatural

\f0\fs20 \cf0 \CocoaLigature1 \
\
How do I run a child process and either retrieve its status or kill it?\
Could use NSTask, if it is a command line process.\
\
What happens if NSTask runs a command that crashes?  The task sends a notification that it terminated, and [theTask terminationStatus] gives the error code such as SIGSEGV.\
\
\

\fs32 Communicating with the task
\fs20 \
\
To initialize the variables and functions, pass dictionary property list XML in command line args.\
\
Hook up pipes to stdin, stdout.\
\
App to task: App writes a NUL-terminated string to be evaluated.  The task can repeatedly call getchar(), watching for NUL or EOF, otherwise appending to a buffer.\
\
Task to app: dictionary property list XML terminated by some special character, maybe FF = '\\f' = 0x0C.  The dictionary would contain: Key @"ResultKind", value ECalcResult; key @"Result", value NSNumber containing double; key @"Stop", value NSNumber containing int; key @"Symbol", value NSString.\
\
}